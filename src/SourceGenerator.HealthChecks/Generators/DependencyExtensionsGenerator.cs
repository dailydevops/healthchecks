namespace SourceGenerator.HealthChecks.Generators;

using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using NetEvolve.CodeBuilder;

[Generator(LanguageNames.CSharp)]
internal sealed class DependencyExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var toBeImplemented = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                AttributeName.Namespace + AttributeName.HealthCheckHelper,
                static (s, _) => IsTargetForGeneration(s),
                static (ctx, _) => GetCandidate(ctx)!
            )
            .Where(c => c is not null);

        context.RegisterSourceOutput(toBeImplemented, static (ctx, candidate) => Generate(ctx, candidate));
    }

    private static void Generate(SourceProductionContext context, Candidate candidate)
    {
        var builder = new CSharpCodeBuilder(500)
            .AppendLine("// <auto-generated />")
            .Append("namespace ")
            .Append(candidate.Namespace)
            .AppendLine(';')
            .AppendLine()
            .AppendLine("using System;")
            .AppendLine("using System.Collections.Generic;")
            .AppendLine("using System.Diagnostics.CodeAnalysis;")
            .AppendLine("using System.Linq;")
            .AppendLine("using Microsoft.Extensions.DependencyInjection;")
            .AppendLine("using Microsoft.Extensions.Diagnostics.HealthChecks;")
            .AppendLine("using Microsoft.Extensions.Options;")
            .AppendLine();

        using (builder.ScopeLine($"partial class {candidate.Name}"))
        {
            _ = builder.AppendLine("[ExcludeFromCodeCoverage]");
            using (
                builder.ScopeLine(
                    "private static bool IsServiceTypeRegistered<T>(this IHealthChecksBuilder builder) where T : class"
                )
            )
            {
                _ = builder
                    .AppendLine("ArgumentNullException.ThrowIfNull(builder);")
                    .AppendLine("return builder.Services.Any(x => x.ServiceType == typeof(T));");
            }

            _ = builder.AppendLine("[ExcludeFromCodeCoverage]");
            using (
                builder.ScopeLine(
                    "private static void ThrowIfNameIsAlreadyUsed<T>(this IHealthChecksBuilder builder, string name) where T : IHealthCheck"
                )
            )
            {
                _ = builder
                    .AppendLine("ArgumentNullException.ThrowIfNull(builder);")
                    .AppendLine("var serviceProvider = builder.Services.BuildServiceProvider();")
                    .AppendLine("using var scope = serviceProvider.CreateScope();")
                    .AppendLine(
                        "var options = scope.ServiceProvider.GetRequiredService<IOptions<HealthCheckServiceOptions>>();"
                    );

                using (
                    builder.ScopeLine(
                        "if (options?.Value?.Registrations is ICollection<HealthCheckRegistration> registrations && registrations.Any(IsNameAlreadyUsedForServiceType))"
                    )
                )
                {
                    _ = builder.AppendLine(
                        "throw new ArgumentException($\"Name `{name}` already in use.\", nameof(name), null);"
                    );
                }

                _ = builder
                    .AppendLine("bool IsNameAlreadyUsedForServiceType(HealthCheckRegistration registration) =>")
                    .AppendLine("registration.Name.Equals(name, StringComparison.OrdinalIgnoreCase)")
                    .AppendLine("&& registration.Factory(scope.ServiceProvider).GetType() == typeof(T);");
            }
        }

        context.AddSource(
            $"{candidate.Name}_DependencyExtensions.g.cs",
            SourceText.From(builder.ToString(), Encoding.UTF8)
        );
    }

    private static bool IsTargetForGeneration(SyntaxNode node) =>
        node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } classNode
        && classNode.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
        && classNode.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword));

    private static Candidate? GetCandidate(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetNode is not ClassDeclarationSyntax classDeclaration)
        {
            return null;
        }

        return GetCandidateInformation(context.SemanticModel, classDeclaration);
    }

    private static Candidate? GetCandidateInformation(
        SemanticModel semanticModel,
        ClassDeclarationSyntax classDeclaration
    )
    {
        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not ISymbol classSymbol)
        {
            return null;
        }

        return new Candidate
        {
            Namespace = classSymbol.ContainingNamespace.ToDisplayString(),
            Name = classDeclaration.Identifier.Text,
        };
    }

    private sealed record Candidate
    {
        public string Namespace { get; set; } = default!;
        public string Name { get; set; } = default!;
    }
}
