namespace SourceGenerator.SqlHealthCheck;

using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

[Generator(LanguageNames.CSharp)]
internal sealed class SqlHealthCheckGenerator : IIncrementalGenerator
{
    public static string Attribute =>
        """
namespace SourceGenerator.SqlHealthCheck;

using System;
using System.Diagnostics.CodeAnalysis;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
[ExcludeFromCodeCoverage]
#pragma warning disable CS9113, CA1019 // Parameter is unread.
internal sealed class GenerateSqlHealthCheckAttribute(Type connectionType, Type optionsType, bool asyncImplementation)
#pragma warning restore CS9113, CA1019 // Parameter is unread.
    : Attribute;
""";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(context =>
            context.AddSource("GenerateSqlHealthCheckAttribute.g.cs", SourceText.From(Attribute, Encoding.UTF8))
        );

        var toBeImplemented = context
            .SyntaxProvider.ForAttributeWithMetadataName<Candidate>(
                "SourceGenerator.SqlHealthCheck.GenerateSqlHealthCheckAttribute",
                static (s, _) => IsTargetForGeneration(s),
                static (ctx, _) => GetCandidate(ctx)!
            )
            .Where(c => c is not null);

        context.RegisterSourceOutput(toBeImplemented, static (ctx, source) => Generate(ctx, source));
    }

    private static void Generate(SourceProductionContext context, Candidate source)
    {
        var content = GenerateSqlHealthCheck(source);

        context.AddSource($"{source.Name}.g.cs", SourceText.From(content, Encoding.UTF8));
    }

    private static string GenerateSqlHealthCheck(Candidate source)
    {
        var indent = 4;
        var sb = new StringBuilder()
            .AppendLine("// <auto-generated />")
            .AppendLine($"namespace {source.Namespace};")
            .AppendLine()
            .AppendLine("using System;")
            .AppendLine("using System.Diagnostics;")
            .AppendLine("using System.Threading;")
            .AppendLine("using System.Threading.Tasks;")
            .AppendLine("using Microsoft.Extensions.Diagnostics.HealthChecks;")
            .AppendLine(source.AsyncImplementation ? "using NetEvolve.Extensions.Tasks;\n" : string.Empty)
            .AppendLine($"partial class {source.Name}")
            .AppendLine("{")
            .Append(' ', indent)
            .AppendLine("/// <inheritdoc />")
            .Append(' ', indent)
            .Append("protected")
            .Append(' ')
            .Append("sealed")
            .Append(' ')
            .Append("override")
            .Append(' ');

        if (source.AsyncImplementation)
        {
            _ = sb.Append("async")
                .Append(' ')
                .Append("ValueTask<HealthCheckResult>")
                .Append(' ')
                .AppendLine(
                    $"ExecuteHealthCheckAsync(string name, HealthStatus failureStatus, {source.OptionsTypeName} options, CancellationToken cancellationToken)"
                )
                .Append(' ', indent)
                .AppendLine("{");

            indent += 4;
            _ = sb.Append(' ', indent)
                .AppendLine("ArgumentNullException.ThrowIfNull(options);")
                .Append(' ', indent)
                .AppendLine(
                    $"var connection = new global::{source.ConnectionTypeNamespace}.{source.ConnectionTypeName}(options.ConnectionString);"
                )
                .Append(' ', indent)
                .AppendLine("await using (connection.ConfigureAwait(false))")
                .Append(' ', indent)
                .AppendLine("{");

            indent += 4;
            _ = sb.Append(' ', indent)
                .AppendLine("await connection.OpenAsync(cancellationToken).ConfigureAwait(false);")
                .Append(' ', indent)
                .AppendLine("var command = connection.CreateCommand();")
                .Append(' ', indent)
                .AppendLine("await using (command.ConfigureAwait(false))")
                .Append(' ', indent)
                .AppendLine("{");

            indent += 4;
            _ = sb.AppendLine("#pragma warning disable CA2100 // Review SQL queries for security vulnerabilities")
                .Append(' ', indent)
                .AppendLine("command.CommandText = options.Command;")
                .AppendLine("#pragma warning restore CA2100 // Review SQL queries for security vulnerabilities")
                .Append(' ', indent)
                .AppendLine(
                    "var (isTimelyResponse, _) = await command.ExecuteNonQueryAsync(cancellationToken).WithTimeoutAsync(options.Timeout, cancellationToken).ConfigureAwait(false);"
                )
                .Append(' ', indent)
                .AppendLine("return HealthCheckState(isTimelyResponse, name);");

            indent -= 4;
            _ = sb.Append(' ', indent).AppendLine("}");
            indent -= 4;
            _ = sb.Append(' ', indent).AppendLine("}");
            indent -= 4;
            _ = sb.Append(' ', indent).AppendLine("}");
        }
        else
        {
            _ = sb.Append("ValueTask<HealthCheckResult>")
                .Append(' ')
                .AppendLine(
                    $"ExecuteHealthCheckAsync(string name, HealthStatus failureStatus, {source.OptionsTypeName} options, CancellationToken cancellationToken)"
                )
                .Append(' ', indent)
                .AppendLine("{");

            indent += 4;
            _ = sb.Append(' ', indent)
                .AppendLine("ArgumentNullException.ThrowIfNull(options);")
                .Append(' ', indent)
                .AppendLine(
                    $"using var connection = new global::{source.ConnectionTypeNamespace}.{source.ConnectionTypeName}(options.ConnectionString);"
                )
                .Append(' ', indent)
                .AppendLine("connection.Open();")
                .Append(' ', indent)
                .AppendLine("using var command = connection.CreateCommand();")
                .AppendLine("#pragma warning disable CA2100 // Review SQL queries for security vulnerabilities")
                .Append(' ', indent)
                .AppendLine("command.CommandText = options.Command;")
                .AppendLine("#pragma warning restore CA2100 // Review SQL queries for security vulnerabilities")
                .Append(' ', indent)
                .AppendLine("var sw = Stopwatch.StartNew();")
                .Append(' ', indent)
                .AppendLine("_ = command.ExecuteNonQuery();")
                .Append(' ', indent)
                .AppendLine("var isTimelyResponse = options.Timeout >= sw.Elapsed.TotalMilliseconds;")
                .Append(' ', indent)
                .AppendLine("return ValueTask.FromResult(HealthCheckState(isTimelyResponse, name));");

            indent -= 4;
            _ = sb.Append(' ', indent).AppendLine("}");
        }

        return sb.Append('}').ToString();
    }

    private static Candidate? GetCandidate(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetNode is not ClassDeclarationSyntax classDeclaration)
        {
            return null;
        }

        var attributeData = context.Attributes.FirstOrDefault(a =>
            a.AttributeClass!.Name == "GenerateSqlHealthCheckAttribute"
        );
        if (attributeData is null)
        {
            return null;
        }

        return GetCandidateInformation(context.SemanticModel, classDeclaration, attributeData);
    }

    private static Candidate? GetCandidateInformation(
        SemanticModel semanticModel,
        ClassDeclarationSyntax classDeclaration,
        AttributeData attributeData
    )
    {
        if (attributeData.ConstructorArguments[0].Value is not ISymbol connectionType)
        {
            return null;
        }

        if (attributeData.ConstructorArguments[1].Value is not ISymbol optionsType)
        {
            return null;
        }

        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not ISymbol classSymbol)
        {
            return null;
        }

        return new Candidate
        {
            AsyncImplementation = attributeData.ConstructorArguments[2].Value is bool value && value,
            Namespace = classSymbol.ContainingNamespace.ToDisplayString(),
            Name = classDeclaration.Identifier.Text,
            ConnectionTypeName = connectionType.Name,
            ConnectionTypeNamespace = connectionType.ContainingNamespace.ToDisplayString(),
            OptionsTypeName = optionsType.Name,
            OptionsTypeNamespace = optionsType.ContainingNamespace.ToDisplayString(),
        };
    }

    private static bool IsTargetForGeneration(SyntaxNode node) =>
        node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };

    private sealed record Candidate
    {
        public bool AsyncImplementation { get; set; }
        public string? Namespace { get; set; }
        public string? Name { get; set; }
        public string? ConnectionTypeName { get; set; }
        public string? ConnectionTypeNamespace { get; set; }
        public string? OptionsTypeName { get; internal set; }
        public string? OptionsTypeNamespace { get; internal set; }
    }
}
